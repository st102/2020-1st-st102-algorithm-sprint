# {소인수 분해}

## 문제 설명
주어진 정수를 소인수 분해하여 출력

## 나의 풀이 방법
현재 수가 1이 될때까지 2부터 시작하여 1씩 증가하며 나눠지는 확인하고 나눠 나아간다. 
만약 5로 나눠졌으면 다음 나눌 소인수를 찾을 때 5부터 시작한다.(이미 4까지는 더이상 안나눠진다는 것이 확인되었으니)
```kotlin
fun primeFactorization(n: Int) {
    var now = n
    var last = 2
    while (now != 1){
        for(i in last .. now){
            if(now%i==0){
                now/=i
                sb.append("$i\n")
                last = i
                break
            }
        }
    }
}

```

## 다른 사람의 풀이 방법
마지막 나눠진 수를 저장하며 반복문을 2개 사용하여 했는데 더 간단하게 할 수 있었다...
만약 나눠지면, i가 증가되는 것을 취소하기 위해 --연산을 한다.
그러다 i가 N을 모두 나눠 1이 되어버리면 i가 더 크니 반복문이 탈출된다.
```c
for (int i = 2; i <= N; i++)
	{
		if (N % i == 0) {
			printf("%d\n", i);
			N /= i;
			i--;
		}
	}
```

## 배운 점
- 간단한 로직이어도 더욱 간단하게 할 수 가 있다는 것을 배웠다.

## 반성할 점
- 마지막수를 저장하면 더 효율적이겠는걸? 하면서 당당히 변수를 추가하였는데, 반복문의 증감 자체를 안시키면 되는 것이었다. 애초에 초기 접근을 반복문 2개로 시작하여 발생한 문제인것 같다.. 문제를 풀기전 조금 더 고민하고 접근해야겠다.

## Action Item
- 코딩하기전 한번더 좋은 방법이 없을지 고민해보자