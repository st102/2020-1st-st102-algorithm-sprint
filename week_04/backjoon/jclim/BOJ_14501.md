# 퇴사

## 문제 설명

* 상담을 완료하는데 걸리는 기간과 상담을 했을 때 받을 수 있는 금액이 주어질 때, N일 동안 얻을 수 있는 최대 수익을 구하는 문제

## 나의 풀이 방법

```c++
#include <iostream>
#include <algorithm>
#define MAX 17

using namespace std;

int days, answer;
pair<int, int> counsel[MAX];
int dp[MAX];

int main(int argc, char** argv)
{
	cin.tie(NULL);
	ios::sync_with_stdio(false);

	cin >> days;

	for (int i = 1; i <= days; i++) {		
		cin >> counsel[i].first >> counsel[i].second;
	}

	for (int i = 1; i <= days; i++) {
		if (i + counsel[i].first <= days + 1) {
			dp[i + counsel[i].first] = max(dp[i + counsel[i].first], dp[i] + counsel[i].second);
			answer = max(answer, dp[i + counsel[i].first]);
		}

		dp[i + 1] = max(dp[i + 1], dp[i]);
		answer = max(answer, dp[i + 1]);
	}

	cout << answer << "\n";
}
```

> `dp[n]`에는 n일까지 얻을 수 있는 최대 수익을 저장한다.  
> i번째 날에 일을 하는 경우와 안하는 경우로 dp 배열의 값을 갱신해가면서 가장 높은 값을 출력했다.  

## 다른 사람의 풀이 방법

```c++
for(int i=1; i<=n + 1; i++){
    for(int j=1; j<i; j++){
        d[i] = max(d[i], d[j]);
            
        if(j + t[j] == i){
            d[i] = max(d[i], d[j] + p[j]);
        }
    }
        
    result = max(result, d[i]);
}
```

> `dp[n]`에 n일까지 얻을 수 있는 최대 수익을 저장하는 것은 동일하지만 dp 배열의 값을 갱신할 때 2중 반복문을 사용하는 풀이다.  

## 배운점

> 같은 DP를 사용한 풀이여도 여러가지 구현 방식이 있는 것을 알 수 있었다.  