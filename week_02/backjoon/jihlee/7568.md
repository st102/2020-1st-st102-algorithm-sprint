덩치
=========

## 문제 설명

자신보다 키와 몸무게가 모두 큰 사람들을 세서 자신의 등수를 출력하는 문제


## 나의 풀이 방법

```c++
pair<int, int> people_info[PEOPLENUM];

int main()
{
    int people_num = 0, height = 0, weight = 0, rank = 1;
    cin >> people_num;

    for (int i = 0; i < people_num; i++) {
        cin >> height >> weight;
        people_info[i] = make_pair(height, weight);
    }

    for (int i = 0; i < people_num; i++) {
        int myrank = 1;
        for (int j = 0; j < people_num; j++) {
            if (i == j)
                continue;

            if (people_info[i].first < people_info[j].first && people_info[i].second < people_info[j].second) 
                myrank++;
        }
        cout << myrank << " ";
    }
    cout << endl;
}

```
이중 for문을 써서 자신을 제외한 모든 배열에서 키와 몸무게가 모두 큰 사람의 수를 세서 출력하도록 하였다.


## 다른 사람의 풀이 방법
```c++

void Solution(int toPick)
{
    if (toPick == num) 
    {
        for (int i = 0; i < num; i++)
            cout << ranking[i] << ' ';
        return;
    }
 
    int cnt = 1;
    for (int i = 0; i < num; i++)
    {
        if (i == toPick) continue;
        if (man[toPick].first < man[i].first && man[toPick].second < man[i].second) cnt++;
    }
    ranking.push_back(cnt);
    Solution(toPick + 1);
}

```
이 풀이 방법은 이중 for문을 사용한 대부분의 풀이와 다르게 재귀함수를 이용한다는 점이 특이했다. 모든 사람의 등수를 ranking배열에 저장하고 다 센 경우 한번에 출력하도록 하였다. 전체적인 매커니즘은 비슷한 것 같다. 

참고 풀이: <https://onlytrying.tistory.com/9>


## 배운점 

-처음에 이중 for문을 쓰고 싶지 않아 정렬기준을 세우고 우선큐에 넣어 등수에 따라 한번에 출력하도록 하였다. 하지만 답은 나오지만 이중 for문을 사용한 풀이 방법에 비해 더 돌아가고 직관적이지 않아 풀이를 다시 짰다.

-배열의 크기가 작다면 직관적인 것이 더 나은 것 같다. 