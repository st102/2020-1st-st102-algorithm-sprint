연결 요소의 개수
=========

## 문제 설명

그래프의 연결 요소의 개수 세기


## 나의 풀이 방법

```c++
void dfs(int node)
{
    visited[node] = true;
    for (int i = 0; i < graph[node].size(); i++) {
        if (!visited[graph[node][i]])
            dfs(graph[node][i]);
    }
}

```
**DFS(깊이 우선 탐색)**에서는 노드와 연결된 노드 중에서 방문하지 은 노드를 찾으면 바로 dfs함수를 호출하여 찾도록 한다. 이 문제는 연결되어 있는 그래프의 수를 찾음으로 main에서 dfs 탐색이 가능한 수(cnt)를 세면 된다. 


## 다른 사람의 풀이 방법
```c++

void bfs(int start)
{
    queue<int> q;

    visited[start] = true;
    q.push(start);
    while (!q.empty()) {
        int current = q.front();
        q.pop();

        int c_size = connected[current].size();
        for (int i = 0; i < c_size; i++) {
            int next = connected[current][i];
            if (!visited[next]) {
                visited[next] = true;
                q.push(next);
            }
        }
    }
}
```
이 풀이 방법은 dfs대신 **BFS**를 이용하여 그래프를 탐색하면서 연결 요소의 개수를 센다. 

참고 풀이: <https://jdselectron.tistory.com/49>


## 배운점 

-이 문제는 인접 행렬보다 인접 리스트로 그래프를 구성했을 때 더 편하게 풀 수 있는 것 같다. 