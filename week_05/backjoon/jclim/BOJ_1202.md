# 보석 도둑

## 문제 설명

* N개의 보석 정보와 K개의 가방 정보가 주어질 때, 훔칠 수 있는 보석의 최대 가격을 구하는 문제

## 나의 풀이 방법

```c++
#include <iostream>
#include <queue>
#include <algorithm>
#define MAX 300000

using namespace std;

int gems, bags;
pair<int, int> gem[MAX];
int bag[MAX];
long long answer;

int main(int argc, char** argv)
{
	cin.tie(NULL);
	ios::sync_with_stdio(false);

	cin >> gems >> bags;

	for (int i = 0; i < gems; i++) {
		cin >> gem[i].first >> gem[i].second;
	}

	for (int i = 0; i < bags; i++) {
		cin >> bag[i];
	}

	sort(gem, gem + gems);
	sort(bag, bag + bags);

	priority_queue<int> pq;

	for (int i = 0, j = 0; i < bags; i++) {
		while (j < gems && gem[j].first <= bag[i]) {
			pq.push(gem[j++].second);
		}

		if (!pq.empty()) {
			answer += pq.top();
			pq.pop();
		}
	}
	
	cout << answer << "\n";
}
```

> 우선 보석과 가방 정보를 배열에 저장하고 둘 다 무게 오름차순으로 정렬한다.  
> 가방의 무게와 보석의 무게를 비교하면서 보석이 더 무거워질 때까지 우선순위 큐에 넣는다.  
> 큐의 맨 앞에는 현재 가방에 넣을 수 있는 보석 중 가장 비싼 보석이 있고 해당 보석을 가방에 넣는다.  
> 이 과정을 반복하여 가방들에 넣을 수 있는 보석 가격의 합의 최댓값을 구하고 출력했다.  

## 다른 사람의 풀이 방법

> 다른 사람들도 비슷한 방식으로 문제를 해결한 것 같다.  

## 배운점

> 정렬과 우선순위 큐를 활용하는것이 중요했던 것 같다.  
> 답을 int형 변수에 저장하면 범위를 초과하여 틀리게 되는데 이런건 잘 확인해야겠다.  