# {보석 도둑}

## 문제 설명
보석들의 무게와 가격을 고려해 다수의 가방에 담아갈때 최고의 가격으로 가져오는 방벙
이때 한 가방에 보석은 하나만 넣을 수 있다.

## 나의 풀이 방법
1. 보석과 가방을 오름차순으로 정렬
2. 가방을 반복문으로 돌며, 우선순위 큐에 해당 가방의 무게까지 감당가능한 보석을 넣는다.
3. 우선순위큐 첫번째값을 더하고, 다음 가방으로 넘어간다.
```kotlin
    bagList.forEach { bagSize ->
        while (jewelryListIndex < N && jewelryList[jewelryListIndex].first<=bagSize) {
            priorityQueue.add(jewelryList[jewelryListIndex].second)
            jewelryListIndex++
        }
        if(priorityQueue.isNotEmpty()){
            sum+=priorityQueue.poll()
        }
    }
```

## 다른 사람의 풀이 방법
우선순위큐를 무게 별로 두어서 각 가방에 감당 가능한 보석들의 큐를 순회하며 맥스를 가져오는 방식
해당 방법은 우선순위큐를 탐색하는 과정이 추가되므로 무게의 범위가 커질 수록 복잡도가 커질 위험이 있다.
    1. MaxHeap을 여러 개 만들어서, 각각의 MaxHeap에 무게가 같은 보석들이 들어가도록 합니다.
        각각의 MaxHeap들을 서로 다른 보석바구니들이라고 생각하겠습니다.
    2. 보석을 넣을 가방들을 용량이 작은 순서부터 꺼낸 뒤, 해당 가방의 용량보다 작거나 같은 보석바구니들에서
        최댓값(president)을 뽑아 최댓값(president)끼리 비교할 수 있는 MaxHeap 안에 넣습니다.
    3. 최댓값(president)들이 들어간 MaxHeap 안에서 한번 최댓값 중의 최댓값(king)을 뽑습니다.
       뽑힌 이 최댓값(king)은 해당 가방에 넣을 수 있는 보석들 중 가장 비싼 보석입니다.
    4. 최댓값(king)이 없어졌으니, 최댓값(king)이 속해있던 보석바구니에서만 최댓값(president)을 뽑아 
        MaxHeap 안에 넣습니다.
    5. (2.)부터 반복합니다.

## 배운 점
- 정렬의 기준과 무엇이 반복의 기준이 되냐에 따라 실행시간이 달라진다.

## 반성할 점
처음 이 문제에 접근할 때, 보석을 가격으로 정렬하여 가장 비싼거를 남아있는 가방으로 감당가능한지를 보는 방식으로 했었다.
정렬의 기준을 무엇으로 잡고 접근하냐에 따라서 복잡도는 비슷하더라도 실제 실행시간에서 차이가 남을 체감했다.
어떤 것이 정렬의 기준이 되어야 할지 좀 더 고민하는 습관을 들이자.

## Action Item
- 정렬이 필요한 경우 효율적인 것을 선택하자!